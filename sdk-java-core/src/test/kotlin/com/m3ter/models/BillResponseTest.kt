// File generated from our OpenAPI spec by Stainless.

package com.m3ter.models

import com.fasterxml.jackson.module.kotlin.jacksonTypeRef
import com.m3ter.core.JsonValue
import com.m3ter.core.jsonMapper
import java.time.LocalDate
import java.time.OffsetDateTime
import kotlin.jvm.optionals.getOrNull
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.Test

internal class BillResponseTest {

    @Test
    fun create() {
        val billResponse =
            BillResponse.builder()
                .id("id")
                .accountCode("accountCode")
                .accountId("accountId")
                .approvedBy("approvedBy")
                .billDate(LocalDate.parse("2019-12-27"))
                .billFrequencyInterval(0)
                .billingFrequency(BillResponse.BillingFrequency.DAILY)
                .billJobId("billJobId")
                .billTotal(0.0)
                .createdBy("createdBy")
                .createdDate(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .csvStatementGenerated(true)
                .currency("currency")
                .addCurrencyConversion(
                    CurrencyConversion.builder().from("EUR").to("USD").multiplier(1.12).build()
                )
                .dtApproved(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .dtCreated(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .dtLastModified(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .dtLocked(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .dueDate(LocalDate.parse("2019-12-27"))
                .endDate(LocalDate.parse("2019-12-27"))
                .endDateTimeUtc(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .externalInvoiceDate(LocalDate.parse("2019-12-27"))
                .externalInvoiceReference("externalInvoiceReference")
                .jsonStatementGenerated(true)
                .lastCalculatedDate(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .lastModifiedBy("lastModifiedBy")
                .addLineItem(
                    BillResponse.LineItem.builder()
                        .averageUnitPrice(0.0)
                        .conversionRate(0.0)
                        .convertedSubtotal(0.0)
                        .currency("x")
                        .description("x")
                        .lineItemType(BillResponse.LineItem.LineItemType.STANDING_CHARGE)
                        .quantity(0.0)
                        .subtotal(0.0)
                        .unit("unit")
                        .units(0.0)
                        .id("id")
                        .accountingProductCode("accountingProductCode")
                        .accountingProductId("accountingProductId")
                        .accountingProductName("accountingProductName")
                        .additional(
                            BillResponse.LineItem.Additional.builder()
                                .putAdditionalProperty("foo", JsonValue.from("bar"))
                                .build()
                        )
                        .aggregationId("aggregationId")
                        .balanceId("balanceId")
                        .chargeId("chargeId")
                        .childAccountCode("childAccountCode")
                        .childAccountId("childAccountId")
                        .commitmentId("commitmentId")
                        .compoundAggregationId("compoundAggregationId")
                        .contractId("contractId")
                        .counterId("counterId")
                        .creditTypeId("creditTypeId")
                        .group(
                            BillResponse.LineItem.Group.builder()
                                .putAdditionalProperty("foo", JsonValue.from("string"))
                                .build()
                        )
                        .meterId("meterId")
                        .planGroupId("planGroupId")
                        .planId("planId")
                        .pricingId("pricingId")
                        .productCode("productCode")
                        .productId("productId")
                        .productName("productName")
                        .reasonId("reasonId")
                        .referencedBillId("referencedBillId")
                        .referencedLineItemId("referencedLineItemId")
                        .segment(
                            BillResponse.LineItem.Segment.builder()
                                .putAdditionalProperty("foo", JsonValue.from("string"))
                                .build()
                        )
                        .sequenceNumber(0)
                        .servicePeriodEndDate(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                        .servicePeriodStartDate(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                        .addUsagePerPricingBand(
                            BillResponse.LineItem.UsagePerPricingBand.builder()
                                .bandQuantity(0.0)
                                .bandSubtotal(0.0)
                                .bandUnits(0.0)
                                .convertedBandSubtotal(0.0)
                                .creditTypeId("creditTypeId")
                                .fixedPrice(0.0)
                                .lowerLimit(0.0)
                                .pricingBandId("pricingBandId")
                                .unitPrice(0.0)
                                .unitSubtotal(0.0)
                                .build()
                        )
                        .build()
                )
                .locked(true)
                .lockedBy("lockedBy")
                .purchaseOrderNumber("purchaseOrderNumber")
                .sequentialInvoiceNumber("sequentialInvoiceNumber")
                .startDate(LocalDate.parse("2019-12-27"))
                .startDateTimeUtc(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .status(BillResponse.Status.PENDING)
                .timezone("UTC")
                .version(0L)
                .build()

        assertThat(billResponse.id()).isEqualTo("id")
        assertThat(billResponse.accountCode()).contains("accountCode")
        assertThat(billResponse.accountId()).contains("accountId")
        assertThat(billResponse.approvedBy()).contains("approvedBy")
        assertThat(billResponse.billDate()).contains(LocalDate.parse("2019-12-27"))
        assertThat(billResponse.billFrequencyInterval()).contains(0)
        assertThat(billResponse.billingFrequency()).contains(BillResponse.BillingFrequency.DAILY)
        assertThat(billResponse.billJobId()).contains("billJobId")
        assertThat(billResponse.billTotal()).contains(0.0)
        assertThat(billResponse.createdBy()).contains("createdBy")
        assertThat(billResponse.createdDate())
            .contains(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
        assertThat(billResponse.csvStatementGenerated()).contains(true)
        assertThat(billResponse.currency()).contains("currency")
        assertThat(billResponse.currencyConversions().getOrNull())
            .containsExactly(
                CurrencyConversion.builder().from("EUR").to("USD").multiplier(1.12).build()
            )
        assertThat(billResponse.dtApproved())
            .contains(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
        assertThat(billResponse.dtCreated())
            .contains(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
        assertThat(billResponse.dtLastModified())
            .contains(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
        assertThat(billResponse.dtLocked())
            .contains(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
        assertThat(billResponse.dueDate()).contains(LocalDate.parse("2019-12-27"))
        assertThat(billResponse.endDate()).contains(LocalDate.parse("2019-12-27"))
        assertThat(billResponse.endDateTimeUtc())
            .contains(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
        assertThat(billResponse.externalInvoiceDate()).contains(LocalDate.parse("2019-12-27"))
        assertThat(billResponse.externalInvoiceReference()).contains("externalInvoiceReference")
        assertThat(billResponse.jsonStatementGenerated()).contains(true)
        assertThat(billResponse.lastCalculatedDate())
            .contains(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
        assertThat(billResponse.lastModifiedBy()).contains("lastModifiedBy")
        assertThat(billResponse.lineItems().getOrNull())
            .containsExactly(
                BillResponse.LineItem.builder()
                    .averageUnitPrice(0.0)
                    .conversionRate(0.0)
                    .convertedSubtotal(0.0)
                    .currency("x")
                    .description("x")
                    .lineItemType(BillResponse.LineItem.LineItemType.STANDING_CHARGE)
                    .quantity(0.0)
                    .subtotal(0.0)
                    .unit("unit")
                    .units(0.0)
                    .id("id")
                    .accountingProductCode("accountingProductCode")
                    .accountingProductId("accountingProductId")
                    .accountingProductName("accountingProductName")
                    .additional(
                        BillResponse.LineItem.Additional.builder()
                            .putAdditionalProperty("foo", JsonValue.from("bar"))
                            .build()
                    )
                    .aggregationId("aggregationId")
                    .balanceId("balanceId")
                    .chargeId("chargeId")
                    .childAccountCode("childAccountCode")
                    .childAccountId("childAccountId")
                    .commitmentId("commitmentId")
                    .compoundAggregationId("compoundAggregationId")
                    .contractId("contractId")
                    .counterId("counterId")
                    .creditTypeId("creditTypeId")
                    .group(
                        BillResponse.LineItem.Group.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .meterId("meterId")
                    .planGroupId("planGroupId")
                    .planId("planId")
                    .pricingId("pricingId")
                    .productCode("productCode")
                    .productId("productId")
                    .productName("productName")
                    .reasonId("reasonId")
                    .referencedBillId("referencedBillId")
                    .referencedLineItemId("referencedLineItemId")
                    .segment(
                        BillResponse.LineItem.Segment.builder()
                            .putAdditionalProperty("foo", JsonValue.from("string"))
                            .build()
                    )
                    .sequenceNumber(0)
                    .servicePeriodEndDate(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .servicePeriodStartDate(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                    .addUsagePerPricingBand(
                        BillResponse.LineItem.UsagePerPricingBand.builder()
                            .bandQuantity(0.0)
                            .bandSubtotal(0.0)
                            .bandUnits(0.0)
                            .convertedBandSubtotal(0.0)
                            .creditTypeId("creditTypeId")
                            .fixedPrice(0.0)
                            .lowerLimit(0.0)
                            .pricingBandId("pricingBandId")
                            .unitPrice(0.0)
                            .unitSubtotal(0.0)
                            .build()
                    )
                    .build()
            )
        assertThat(billResponse.locked()).contains(true)
        assertThat(billResponse.lockedBy()).contains("lockedBy")
        assertThat(billResponse.purchaseOrderNumber()).contains("purchaseOrderNumber")
        assertThat(billResponse.sequentialInvoiceNumber()).contains("sequentialInvoiceNumber")
        assertThat(billResponse.startDate()).contains(LocalDate.parse("2019-12-27"))
        assertThat(billResponse.startDateTimeUtc())
            .contains(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
        assertThat(billResponse.status()).contains(BillResponse.Status.PENDING)
        assertThat(billResponse.timezone()).contains("UTC")
        assertThat(billResponse.version()).contains(0L)
    }

    @Test
    fun roundtrip() {
        val jsonMapper = jsonMapper()
        val billResponse =
            BillResponse.builder()
                .id("id")
                .accountCode("accountCode")
                .accountId("accountId")
                .approvedBy("approvedBy")
                .billDate(LocalDate.parse("2019-12-27"))
                .billFrequencyInterval(0)
                .billingFrequency(BillResponse.BillingFrequency.DAILY)
                .billJobId("billJobId")
                .billTotal(0.0)
                .createdBy("createdBy")
                .createdDate(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .csvStatementGenerated(true)
                .currency("currency")
                .addCurrencyConversion(
                    CurrencyConversion.builder().from("EUR").to("USD").multiplier(1.12).build()
                )
                .dtApproved(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .dtCreated(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .dtLastModified(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .dtLocked(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .dueDate(LocalDate.parse("2019-12-27"))
                .endDate(LocalDate.parse("2019-12-27"))
                .endDateTimeUtc(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .externalInvoiceDate(LocalDate.parse("2019-12-27"))
                .externalInvoiceReference("externalInvoiceReference")
                .jsonStatementGenerated(true)
                .lastCalculatedDate(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .lastModifiedBy("lastModifiedBy")
                .addLineItem(
                    BillResponse.LineItem.builder()
                        .averageUnitPrice(0.0)
                        .conversionRate(0.0)
                        .convertedSubtotal(0.0)
                        .currency("x")
                        .description("x")
                        .lineItemType(BillResponse.LineItem.LineItemType.STANDING_CHARGE)
                        .quantity(0.0)
                        .subtotal(0.0)
                        .unit("unit")
                        .units(0.0)
                        .id("id")
                        .accountingProductCode("accountingProductCode")
                        .accountingProductId("accountingProductId")
                        .accountingProductName("accountingProductName")
                        .additional(
                            BillResponse.LineItem.Additional.builder()
                                .putAdditionalProperty("foo", JsonValue.from("bar"))
                                .build()
                        )
                        .aggregationId("aggregationId")
                        .balanceId("balanceId")
                        .chargeId("chargeId")
                        .childAccountCode("childAccountCode")
                        .childAccountId("childAccountId")
                        .commitmentId("commitmentId")
                        .compoundAggregationId("compoundAggregationId")
                        .contractId("contractId")
                        .counterId("counterId")
                        .creditTypeId("creditTypeId")
                        .group(
                            BillResponse.LineItem.Group.builder()
                                .putAdditionalProperty("foo", JsonValue.from("string"))
                                .build()
                        )
                        .meterId("meterId")
                        .planGroupId("planGroupId")
                        .planId("planId")
                        .pricingId("pricingId")
                        .productCode("productCode")
                        .productId("productId")
                        .productName("productName")
                        .reasonId("reasonId")
                        .referencedBillId("referencedBillId")
                        .referencedLineItemId("referencedLineItemId")
                        .segment(
                            BillResponse.LineItem.Segment.builder()
                                .putAdditionalProperty("foo", JsonValue.from("string"))
                                .build()
                        )
                        .sequenceNumber(0)
                        .servicePeriodEndDate(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                        .servicePeriodStartDate(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                        .addUsagePerPricingBand(
                            BillResponse.LineItem.UsagePerPricingBand.builder()
                                .bandQuantity(0.0)
                                .bandSubtotal(0.0)
                                .bandUnits(0.0)
                                .convertedBandSubtotal(0.0)
                                .creditTypeId("creditTypeId")
                                .fixedPrice(0.0)
                                .lowerLimit(0.0)
                                .pricingBandId("pricingBandId")
                                .unitPrice(0.0)
                                .unitSubtotal(0.0)
                                .build()
                        )
                        .build()
                )
                .locked(true)
                .lockedBy("lockedBy")
                .purchaseOrderNumber("purchaseOrderNumber")
                .sequentialInvoiceNumber("sequentialInvoiceNumber")
                .startDate(LocalDate.parse("2019-12-27"))
                .startDateTimeUtc(OffsetDateTime.parse("2019-12-27T18:11:19.117Z"))
                .status(BillResponse.Status.PENDING)
                .timezone("UTC")
                .version(0L)
                .build()

        val roundtrippedBillResponse =
            jsonMapper.readValue(
                jsonMapper.writeValueAsString(billResponse),
                jacksonTypeRef<BillResponse>(),
            )

        assertThat(roundtrippedBillResponse).isEqualTo(billResponse)
    }
}
